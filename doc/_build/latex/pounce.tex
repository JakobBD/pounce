%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\makeatletter
\def\fnum@figure{\figurename\thefigure{}}
\makeatother
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\makeatletter
\def\fnum@table{\tablename\thetable{}}
\makeatother
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}


\title{pounce Documentation}
\date{Oct 11, 2019}
\release{}
\author{JD}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{helpers package}
\label{\detokenize{helpers:helpers-package}}\label{\detokenize{helpers::doc}}

\section{Submodules}
\label{\detokenize{helpers:submodules}}

\section{helpers.baseclass module}
\label{\detokenize{helpers:module-helpers.baseclass}}\label{\detokenize{helpers:helpers-baseclass-module}}\index{helpers.baseclass (module)@\spxentry{helpers.baseclass}\spxextra{module}}\index{BaseClass (class in helpers.baseclass)@\spxentry{BaseClass}\spxextra{class in helpers.baseclass}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.baseclass.BaseClass}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{helpers.baseclass.}}\sphinxbfcode{\sphinxupquote{BaseClass}}}{\emph{class\_dict}, \emph{*further\_classes}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Skeleton for most classes to inherit from.
Provides methods for user input and to choose subclasses from a 
user input string
\index{create() (helpers.baseclass.BaseClass class method)@\spxentry{create()}\spxextra{helpers.baseclass.BaseClass class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.baseclass.BaseClass.create}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{create}}}{\emph{class\_dict}, \emph{*args}}{}
Choose subclass via a input string and init.
Further user input for this class is passed to init as a dict

\end{fulllineitems}

\index{defaults() (helpers.baseclass.BaseClass class method)@\spxentry{defaults()}\spxextra{helpers.baseclass.BaseClass class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.baseclass.BaseClass.defaults}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{defaults}}}{\emph{*args}, \emph{with\_type=True}}{}
get defaults for a class, first from its own class and parents, 
then from further input classes.
\_type (i.e. the subclass name) is added optionally

\end{fulllineitems}

\index{defaults\_class() (helpers.baseclass.BaseClass class method)@\spxentry{defaults\_class()}\spxextra{helpers.baseclass.BaseClass class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.baseclass.BaseClass.defaults_class}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{defaults\_class}}}{\emph{key=None}}{}
get defaults for a class from its own class and parents, 
via the multi resolution order list.

\end{fulllineitems}

\index{name() (helpers.baseclass.BaseClass class method)@\spxentry{name()}\spxextra{helpers.baseclass.BaseClass class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.baseclass.BaseClass.name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{name}}}{}{}
translate class name from camel case (MyClass) to 
underscore (my\_class) for consistent yml input

\end{fulllineitems}

\index{read\_prms() (helpers.baseclass.BaseClass method)@\spxentry{read\_prms()}\spxextra{helpers.baseclass.BaseClass method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.baseclass.BaseClass.read_prms}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read\_prms}}}{\emph{input\_prm\_dict}, \emph{*further\_classes}}{}
Gets user input for own class as a dictionary.
Compares user input against defaults for parent class and 
subclass. Throws errors for invali input, else converts input 
dict to class attributes

\end{fulllineitems}

\index{subclass() (helpers.baseclass.BaseClass class method)@\spxentry{subclass()}\spxextra{helpers.baseclass.BaseClass class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.baseclass.BaseClass.subclass}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{subclass}}}{\emph{string}}{}
choose subclass of a class by string

\end{fulllineitems}


\end{fulllineitems}

\index{InputPrmError@\spxentry{InputPrmError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.baseclass.InputPrmError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{helpers.baseclass.}}\sphinxbfcode{\sphinxupquote{InputPrmError}}}
Bases: \sphinxcode{\sphinxupquote{Exception}}

\end{fulllineitems}



\section{helpers.config module}
\label{\detokenize{helpers:module-helpers.config}}\label{\detokenize{helpers:helpers-config-module}}\index{helpers.config (module)@\spxentry{helpers.config}\spxextra{module}}\index{GeneralConfig (class in helpers.config)@\spxentry{GeneralConfig}\spxextra{class in helpers.config}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.config.GeneralConfig}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{helpers.config.}}\sphinxbfcode{\sphinxupquote{GeneralConfig}}}{\emph{*args}}{}
Bases: {\hyperref[\detokenize{helpers:helpers.baseclass.BaseClass}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{helpers.baseclass.BaseClass}}}}}

Provides a container for some general config options and their
default values.
\index{copy\_to\_globels() (helpers.config.GeneralConfig method)@\spxentry{copy\_to\_globels()}\spxextra{helpers.config.GeneralConfig method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.config.GeneralConfig.copy_to_globels}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy\_to\_globels}}}{}{}
\end{fulllineitems}

\index{defaults\_ (helpers.config.GeneralConfig attribute)@\spxentry{defaults\_}\spxextra{helpers.config.GeneralConfig attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.config.GeneralConfig.defaults_}}\pysigline{\sphinxbfcode{\sphinxupquote{defaults\_}}\sphinxbfcode{\sphinxupquote{ = \{'archive\_level': 0, 'project\_name': 'NODEFAULT'\}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{config() (in module helpers.config)@\spxentry{config()}\spxextra{in module helpers.config}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.config.config}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.config.}}\sphinxbfcode{\sphinxupquote{config}}}{\emph{prmfile}}{}
Reads all user input and sets up (sub-)classes according to this
input.
Partially, setup is called from uq-method-specific routines.
The sim object is copied to globels to be available for pickle.

\end{fulllineitems}

\index{config\_list() (in module helpers.config)@\spxentry{config\_list()}\spxextra{in module helpers.config}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.config.config_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.config.}}\sphinxbfcode{\sphinxupquote{config\_list}}}{\emph{name}, \emph{prms}, \emph{class\_init}, \emph{*args}, \emph{sub\_list\_name=None}}{}
Checks for correct input format for list type input and
initializes (sub-) class for given input

\end{fulllineitems}

\index{restart() (in module helpers.config)@\spxentry{restart()}\spxextra{in module helpers.config}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.config.restart}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.config.}}\sphinxbfcode{\sphinxupquote{restart}}}{\emph{prmfile=None}}{}
restart simulation from a pickle file.

\end{fulllineitems}



\section{helpers.default\_yml module}
\label{\detokenize{helpers:module-helpers.default_yml}}\label{\detokenize{helpers:helpers-default-yml-module}}\index{helpers.default\_yml (module)@\spxentry{helpers.default\_yml}\spxextra{module}}\index{DefaultFile (class in helpers.default\_yml)@\spxentry{DefaultFile}\spxextra{class in helpers.default\_yml}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.default_yml.DefaultFile}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{helpers.default\_yml.}}\sphinxbfcode{\sphinxupquote{DefaultFile}}}
Bases: \sphinxcode{\sphinxupquote{object}}

container for the defaults dictionary and its manipulating
functions
\index{clean() (helpers.default\_yml.DefaultFile method)@\spxentry{clean()}\spxextra{helpers.default\_yml.DefaultFile method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.default_yml.DefaultFile.clean}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clean}}}{}{}
remove input prms with value “dummy\_unused”;
wrapper for recursive function {\color{red}\bfseries{}clean\_}

\end{fulllineitems}

\index{clean\_() (helpers.default\_yml.DefaultFile method)@\spxentry{clean\_()}\spxextra{helpers.default\_yml.DefaultFile method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.default_yml.DefaultFile.clean_}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clean\_}}}{\emph{dict\_in}}{}
recursively remove input prms with value “dummy\_unused”

\end{fulllineitems}

\index{expand\_to\_several() (helpers.default\_yml.DefaultFile method)@\spxentry{expand\_to\_several()}\spxextra{helpers.default\_yml.DefaultFile method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.default_yml.DefaultFile.expand_to_several}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{expand\_to\_several}}}{\emph{sub}, \emph{list\_name}, \emph{keys=None}, \emph{exclude={[}{]}}}{}
Some classes will have several instances. 
In the ini file, it is desirable to specify some defaults for
all instances, and some for each instance seperately.
In this routine, the defaults of a class are split into a dict
(if keys are given) or a list with one example entry (else)
each including all defaults of the class but the excluded ones. 
This sub-dict/list is then placed inside the default dict for 
the class. The excluded items are specified once and are used
for all instances of the class.

\end{fulllineitems}

\index{get\_list\_defaults() (helpers.default\_yml.DefaultFile method)@\spxentry{get\_list\_defaults()}\spxextra{helpers.default\_yml.DefaultFile method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.default_yml.DefaultFile.get_list_defaults}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_list\_defaults}}}{\emph{parent}, \emph{args='default'}}{}
output a list of all implemented types of list-input items
(e.g. stoch\_var, qoi)

\end{fulllineitems}

\index{get\_machine() (helpers.default\_yml.DefaultFile method)@\spxentry{get\_machine()}\spxextra{helpers.default\_yml.DefaultFile method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.default_yml.DefaultFile.get_machine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_machine}}}{}{}
\end{fulllineitems}

\index{inquire() (helpers.default\_yml.DefaultFile method)@\spxentry{inquire()}\spxextra{helpers.default\_yml.DefaultFile method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.default_yml.DefaultFile.inquire}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inquire}}}{\emph{msg}}{}
\end{fulllineitems}

\index{inquire\_subclass() (helpers.default\_yml.DefaultFile method)@\spxentry{inquire\_subclass()}\spxextra{helpers.default\_yml.DefaultFile method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.default_yml.DefaultFile.inquire_subclass}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inquire\_subclass}}}{\emph{parent\_class}, \emph{description=None}}{}
Asks for user input to choose one of the available subclasses

\end{fulllineitems}

\index{print\_() (helpers.default\_yml.DefaultFile method)@\spxentry{print\_()}\spxextra{helpers.default\_yml.DefaultFile method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.default_yml.DefaultFile.print_}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{print\_}}}{}{}
print dict of defaults either to stdout or to specified file

\end{fulllineitems}

\index{process\_subclass() (helpers.default\_yml.DefaultFile method)@\spxentry{process\_subclass()}\spxextra{helpers.default\_yml.DefaultFile method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.default_yml.DefaultFile.process_subclass}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{process\_subclass}}}{\emph{parent}}{}
inquires subclass, and adds its default prms to dict. 
Returns the class as an object

\end{fulllineitems}


\end{fulllineitems}

\index{print\_default\_yml\_file() (in module helpers.default\_yml)@\spxentry{print\_default\_yml\_file()}\spxextra{in module helpers.default\_yml}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.default_yml.print_default_yml_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.default\_yml.}}\sphinxbfcode{\sphinxupquote{print\_default\_yml\_file}}}{}{}
Asks for user input to choose one of the available subclasses,
builds up dictionary of defaults for all variables for this sub
class combinatiion, then prints default YML file using yaml.dump.

\end{fulllineitems}



\section{helpers.globels module}
\label{\detokenize{helpers:module-helpers.globels}}\label{\detokenize{helpers:helpers-globels-module}}\index{helpers.globels (module)@\spxentry{helpers.globels}\spxextra{module}}\index{archive() (in module helpers.globels)@\spxentry{archive()}\spxextra{in module helpers.globels}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.globels.archive}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.globels.}}\sphinxbfcode{\sphinxupquote{archive}}}{}{}
\end{fulllineitems}

\index{archive\_loc() (in module helpers.globels)@\spxentry{archive\_loc()}\spxextra{in module helpers.globels}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.globels.archive_loc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.globels.}}\sphinxbfcode{\sphinxupquote{archive\_loc}}}{}{}
\end{fulllineitems}

\index{iteration() (in module helpers.globels)@\spxentry{iteration()}\spxextra{in module helpers.globels}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.globels.iteration}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.globels.}}\sphinxbfcode{\sphinxupquote{iteration}}}{\emph{wrapped\_function}}{}
\end{fulllineitems}

\index{run\_step() (in module helpers.globels)@\spxentry{run\_step()}\spxextra{in module helpers.globels}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.globels.run_step}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.globels.}}\sphinxbfcode{\sphinxupquote{run\_step}}}{\emph{description}, \emph{func}, \emph{*args}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{update\_step() (in module helpers.globels)@\spxentry{update\_step()}\spxextra{in module helpers.globels}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.globels.update_step}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.globels.}}\sphinxbfcode{\sphinxupquote{update\_step}}}{\emph{string=None}}{}
\end{fulllineitems}



\section{helpers.printtools module}
\label{\detokenize{helpers:module-helpers.printtools}}\label{\detokenize{helpers:helpers-printtools-module}}\index{helpers.printtools (module)@\spxentry{helpers.printtools}\spxextra{module}}\index{Bcolors (class in helpers.printtools)@\spxentry{Bcolors}\spxextra{class in helpers.printtools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.Bcolors}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{helpers.printtools.}}\sphinxbfcode{\sphinxupquote{Bcolors}}}
Bases: \sphinxcode{\sphinxupquote{object}}

color and font style definitions for changing output appearance
\index{BLACK (helpers.printtools.Bcolors attribute)@\spxentry{BLACK}\spxextra{helpers.printtools.Bcolors attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.Bcolors.BLACK}}\pysigline{\sphinxbfcode{\sphinxupquote{BLACK}}\sphinxbfcode{\sphinxupquote{ = '\textbackslash{}x1b{[}0;30m'}}}
\end{fulllineitems}

\index{BLUE (helpers.printtools.Bcolors attribute)@\spxentry{BLUE}\spxextra{helpers.printtools.Bcolors attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.Bcolors.BLUE}}\pysigline{\sphinxbfcode{\sphinxupquote{BLUE}}\sphinxbfcode{\sphinxupquote{ = '\textbackslash{}x1b{[}0;34m'}}}
\end{fulllineitems}

\index{BOLD (helpers.printtools.Bcolors attribute)@\spxentry{BOLD}\spxextra{helpers.printtools.Bcolors attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.Bcolors.BOLD}}\pysigline{\sphinxbfcode{\sphinxupquote{BOLD}}\sphinxbfcode{\sphinxupquote{ = '\textbackslash{}x1b{[}1m'}}}
\end{fulllineitems}

\index{CYAN (helpers.printtools.Bcolors attribute)@\spxentry{CYAN}\spxextra{helpers.printtools.Bcolors attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.Bcolors.CYAN}}\pysigline{\sphinxbfcode{\sphinxupquote{CYAN}}\sphinxbfcode{\sphinxupquote{ = '\textbackslash{}x1b{[}0;36m'}}}
\end{fulllineitems}

\index{ENDC (helpers.printtools.Bcolors attribute)@\spxentry{ENDC}\spxextra{helpers.printtools.Bcolors attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.Bcolors.ENDC}}\pysigline{\sphinxbfcode{\sphinxupquote{ENDC}}\sphinxbfcode{\sphinxupquote{ = '\textbackslash{}x1b{[}0m'}}}
\end{fulllineitems}

\index{GREEN (helpers.printtools.Bcolors attribute)@\spxentry{GREEN}\spxextra{helpers.printtools.Bcolors attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.Bcolors.GREEN}}\pysigline{\sphinxbfcode{\sphinxupquote{GREEN}}\sphinxbfcode{\sphinxupquote{ = '\textbackslash{}x1b{[}0;32m'}}}
\end{fulllineitems}

\index{PURPLE (helpers.printtools.Bcolors attribute)@\spxentry{PURPLE}\spxextra{helpers.printtools.Bcolors attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.Bcolors.PURPLE}}\pysigline{\sphinxbfcode{\sphinxupquote{PURPLE}}\sphinxbfcode{\sphinxupquote{ = '\textbackslash{}x1b{[}0;35m'}}}
\end{fulllineitems}

\index{RED (helpers.printtools.Bcolors attribute)@\spxentry{RED}\spxextra{helpers.printtools.Bcolors attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.Bcolors.RED}}\pysigline{\sphinxbfcode{\sphinxupquote{RED}}\sphinxbfcode{\sphinxupquote{ = '\textbackslash{}x1b{[}0;31m'}}}
\end{fulllineitems}

\index{UNDERLINE (helpers.printtools.Bcolors attribute)@\spxentry{UNDERLINE}\spxextra{helpers.printtools.Bcolors attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.Bcolors.UNDERLINE}}\pysigline{\sphinxbfcode{\sphinxupquote{UNDERLINE}}\sphinxbfcode{\sphinxupquote{ = '\textbackslash{}x1b{[}4m'}}}
\end{fulllineitems}

\index{WHITE (helpers.printtools.Bcolors attribute)@\spxentry{WHITE}\spxextra{helpers.printtools.Bcolors attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.Bcolors.WHITE}}\pysigline{\sphinxbfcode{\sphinxupquote{WHITE}}\sphinxbfcode{\sphinxupquote{ = '\textbackslash{}x1b{[}0;37m'}}}
\end{fulllineitems}

\index{YELLOW (helpers.printtools.Bcolors attribute)@\spxentry{YELLOW}\spxextra{helpers.printtools.Bcolors attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.Bcolors.YELLOW}}\pysigline{\sphinxbfcode{\sphinxupquote{YELLOW}}\sphinxbfcode{\sphinxupquote{ = '\textbackslash{}x1b{[}0;33m'}}}
\end{fulllineitems}


\end{fulllineitems}

\index{StdOutTable (class in helpers.printtools)@\spxentry{StdOutTable}\spxextra{class in helpers.printtools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.StdOutTable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{helpers.printtools.}}\sphinxbfcode{\sphinxupquote{StdOutTable}}}{\emph{*args}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Buffers several values for each batch for stdout in ordered table.
Called in three steps:
- before loop over batches: init class and set\_descriptions
- during loop over batches: update (for each batch) 
- after  loop over batches: print
\index{p\_print() (helpers.printtools.StdOutTable method)@\spxentry{p\_print()}\spxextra{helpers.printtools.StdOutTable method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.StdOutTable.p_print}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{p\_print}}}{}{}
\end{fulllineitems}

\index{print\_row\_by\_name() (helpers.printtools.StdOutTable method)@\spxentry{print\_row\_by\_name()}\spxextra{helpers.printtools.StdOutTable method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.StdOutTable.print_row_by_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{print\_row\_by\_name}}}{\emph{attr}}{}
\end{fulllineitems}

\index{set\_descriptions() (helpers.printtools.StdOutTable method)@\spxentry{set\_descriptions()}\spxextra{helpers.printtools.StdOutTable method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.StdOutTable.set_descriptions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_descriptions}}}{\emph{*args}}{}
\end{fulllineitems}

\index{update() (helpers.printtools.StdOutTable method)@\spxentry{update()}\spxextra{helpers.printtools.StdOutTable method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.StdOutTable.update}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update}}}{\emph{level}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{TableRow (class in helpers.printtools)@\spxentry{TableRow}\spxextra{class in helpers.printtools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.TableRow}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{helpers.printtools.}}\sphinxbfcode{\sphinxupquote{TableRow}}}{\emph{attr}}{}
Bases: \sphinxcode{\sphinxupquote{object}}
\index{add\_string() (helpers.printtools.TableRow method)@\spxentry{add\_string()}\spxextra{helpers.printtools.TableRow method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.TableRow.add_string}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_string}}}{\emph{string}}{}
\end{fulllineitems}

\index{p\_print() (helpers.printtools.TableRow method)@\spxentry{p\_print()}\spxextra{helpers.printtools.TableRow method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.TableRow.p_print}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{p\_print}}}{\emph{l}, \emph{lm2}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{blue() (in module helpers.printtools)@\spxentry{blue()}\spxextra{in module helpers.printtools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.blue}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.printtools.}}\sphinxbfcode{\sphinxupquote{blue}}}{\emph{text}}{}
\end{fulllineitems}

\index{cyan() (in module helpers.printtools)@\spxentry{cyan()}\spxextra{in module helpers.printtools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.cyan}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.printtools.}}\sphinxbfcode{\sphinxupquote{cyan}}}{\emph{text}}{}
\end{fulllineitems}

\index{green() (in module helpers.printtools)@\spxentry{green()}\spxextra{in module helpers.printtools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.green}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.printtools.}}\sphinxbfcode{\sphinxupquote{green}}}{\emph{text}}{}
\end{fulllineitems}

\index{indent\_in() (in module helpers.printtools)@\spxentry{indent\_in()}\spxextra{in module helpers.printtools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.indent_in}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.printtools.}}\sphinxbfcode{\sphinxupquote{indent\_in}}}{}{}
\end{fulllineitems}

\index{indent\_out() (in module helpers.printtools)@\spxentry{indent\_out()}\spxextra{in module helpers.printtools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.indent_out}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.printtools.}}\sphinxbfcode{\sphinxupquote{indent\_out}}}{}{}
\end{fulllineitems}

\index{p\_print() (in module helpers.printtools)@\spxentry{p\_print()}\spxextra{in module helpers.printtools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.p_print}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.printtools.}}\sphinxbfcode{\sphinxupquote{p\_print}}}{\emph{msg}}{}
wrapper for normal stdout print commands

\end{fulllineitems}

\index{print\_header() (in module helpers.printtools)@\spxentry{print\_header()}\spxextra{in module helpers.printtools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.print_header}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.printtools.}}\sphinxbfcode{\sphinxupquote{print\_header}}}{}{}
\end{fulllineitems}

\index{print\_major\_section() (in module helpers.printtools)@\spxentry{print\_major\_section()}\spxextra{in module helpers.printtools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.print_major_section}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.printtools.}}\sphinxbfcode{\sphinxupquote{print\_major\_section}}}{\emph{msg}, \emph{color='stdcolor'}}{}
such as at the beginning of iterations

\end{fulllineitems}

\index{print\_step() (in module helpers.printtools)@\spxentry{print\_step()}\spxextra{in module helpers.printtools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.print_step}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.printtools.}}\sphinxbfcode{\sphinxupquote{print\_step}}}{\emph{msg}}{}
\end{fulllineitems}

\index{red() (in module helpers.printtools)@\spxentry{red()}\spxextra{in module helpers.printtools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.red}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.printtools.}}\sphinxbfcode{\sphinxupquote{red}}}{\emph{text}}{}
\end{fulllineitems}

\index{time\_to\_str2() (in module helpers.printtools)@\spxentry{time\_to\_str2()}\spxextra{in module helpers.printtools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.time_to_str2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.printtools.}}\sphinxbfcode{\sphinxupquote{time\_to\_str2}}}{\emph{sec}}{}
\end{fulllineitems}

\index{yellow() (in module helpers.printtools)@\spxentry{yellow()}\spxextra{in module helpers.printtools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.printtools.yellow}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.printtools.}}\sphinxbfcode{\sphinxupquote{yellow}}}{\emph{text}}{}
\end{fulllineitems}



\section{helpers.tools module}
\label{\detokenize{helpers:module-helpers.tools}}\label{\detokenize{helpers:helpers-tools-module}}\index{helpers.tools (module)@\spxentry{helpers.tools}\spxextra{module}}\index{Empty (class in helpers.tools)@\spxentry{Empty}\spxextra{class in helpers.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.tools.Empty}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{helpers.tools.}}\sphinxbfcode{\sphinxupquote{Empty}}}
Bases: \sphinxcode{\sphinxupquote{object}}

\end{fulllineitems}

\index{InputPrmError@\spxentry{InputPrmError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.tools.InputPrmError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{helpers.tools.}}\sphinxbfcode{\sphinxupquote{InputPrmError}}}
Bases: \sphinxcode{\sphinxupquote{Exception}}

\end{fulllineitems}

\index{isvalidlist() (in module helpers.tools)@\spxentry{isvalidlist()}\spxextra{in module helpers.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.tools.isvalidlist}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.tools.}}\sphinxbfcode{\sphinxupquote{isvalidlist}}}{\emph{arg}}{}
time lists have three entries h,m,s

\end{fulllineitems}

\index{parse\_time\_to\_seconds() (in module helpers.tools)@\spxentry{parse\_time\_to\_seconds()}\spxextra{in module helpers.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.tools.parse_time_to_seconds}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.tools.}}\sphinxbfcode{\sphinxupquote{parse\_time\_to\_seconds}}}{\emph{arg}}{}
parse different formats to give time in the yml parameter file.

\end{fulllineitems}

\index{safe\_sqrt() (in module helpers.tools)@\spxentry{safe\_sqrt()}\spxextra{in module helpers.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.tools.safe_sqrt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.tools.}}\sphinxbfcode{\sphinxupquote{safe\_sqrt}}}{\emph{arg}}{}
for sqrt of negative values, print a warning instead of crashing.

\end{fulllineitems}

\index{sec\_to\_list() (in module helpers.tools)@\spxentry{sec\_to\_list()}\spxextra{in module helpers.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.tools.sec_to_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.tools.}}\sphinxbfcode{\sphinxupquote{sec\_to\_list}}}{\emph{sec}}{}
helper for time\_sto\_str

\end{fulllineitems}

\index{time\_to\_str() (in module helpers.tools)@\spxentry{time\_to\_str()}\spxextra{in module helpers.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.tools.time_to_str}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.tools.}}\sphinxbfcode{\sphinxupquote{time\_to\_str}}}{\emph{sec}}{}
\end{fulllineitems}

\index{time\_to\_str2() (in module helpers.tools)@\spxentry{time\_to\_str2()}\spxextra{in module helpers.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{helpers:helpers.tools.time_to_str2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{helpers.tools.}}\sphinxbfcode{\sphinxupquote{time\_to\_str2}}}{\emph{sec}}{}
\end{fulllineitems}



\section{Module contents}
\label{\detokenize{helpers:module-helpers}}\label{\detokenize{helpers:module-contents}}\index{helpers (module)@\spxentry{helpers}\spxextra{module}}

\chapter{machine package}
\label{\detokenize{machine:machine-package}}\label{\detokenize{machine::doc}}

\section{Submodules}
\label{\detokenize{machine:submodules}}

\section{machine.cray module}
\label{\detokenize{machine:module-machine.cray}}\label{\detokenize{machine:machine-cray-module}}\index{machine.cray (module)@\spxentry{machine.cray}\spxextra{module}}\index{Cray (class in machine.cray)@\spxentry{Cray}\spxextra{class in machine.cray}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.cray.Cray}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{machine.cray.}}\sphinxbfcode{\sphinxupquote{Cray}}}{\emph{class\_dict}}{}
Bases: {\hyperref[\detokenize{machine:machine.machine.Machine}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{machine.machine.Machine}}}}}

Definition of Cray Hazelhen machine.
\index{allocate\_resources() (machine.cray.Cray method)@\spxentry{allocate\_resources()}\spxextra{machine.cray.Cray method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.cray.Cray.allocate_resources}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{allocate\_resources}}}{}{}
Takes the properties of the batch (number of current samples,
walltime and cores of current sample) as well as the machine 
properties or machine input (number of cores per node, max nodes
etc.) and outputs number of cores and number of parallel runs 
for this batch.

\end{fulllineitems}

\index{check\_errorfile() (machine.cray.Cray method)@\spxentry{check\_errorfile()}\spxextra{machine.cray.Cray method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.cray.Cray.check_errorfile}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_errorfile}}}{\emph{batch}}{}
open error file and parse errrors. 
Well, parse is a strong word here.

\end{fulllineitems}

\index{defaults\_ (machine.cray.Cray attribute)@\spxentry{defaults\_}\spxextra{machine.cray.Cray attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.cray.Cray.defaults_}}\pysigline{\sphinxbfcode{\sphinxupquote{defaults\_}}\sphinxbfcode{\sphinxupquote{ = \{'max\_total\_work': 3600000.0, 'max\_walltime': 86400, 'n\_max\_cores': 10000, 'walltime\_factor': 1.2\}}}}
\end{fulllineitems}

\index{get\_best\_option() (machine.cray.Cray method)@\spxentry{get\_best\_option()}\spxextra{machine.cray.Cray method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.cray.Cray.get_best_option}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_best\_option}}}{\emph{batch}}{}
Loop over all possible combinations of n\_parallel\_runs and 
n\_sequential\_runs.
Get Rating for all of them. Pick the best one.

\end{fulllineitems}

\index{get\_package\_properties() (machine.cray.Cray method)@\spxentry{get\_package\_properties()}\spxextra{machine.cray.Cray method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.cray.Cray.get_package_properties}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_package\_properties}}}{\emph{batch}}{}
define a “package” of runs to fill a node, 
e.g. 4 parallel runs with cores\_per\_sample=6.
trivial if cores\_per\_sample \textgreater{}= 24.

\end{fulllineitems}

\index{read\_qstat() (machine.cray.Cray method)@\spxentry{read\_qstat()}\spxextra{machine.cray.Cray method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.cray.Cray.read_qstat}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read\_qstat}}}{}{}
run ‘qstat’ on cray and read output

\end{fulllineitems}

\index{run\_batches() (machine.cray.Cray method)@\spxentry{run\_batches()}\spxextra{machine.cray.Cray method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.cray.Cray.run_batches}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run\_batches}}}{}{}
Runs batches by generating the necessary jobfiles,
submitting them, and supervising the queuing status.

\end{fulllineitems}

\index{submit\_job() (machine.cray.Cray method)@\spxentry{submit\_job()}\spxextra{machine.cray.Cray method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.cray.Cray.submit_job}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{submit\_job}}}{\emph{batch}}{}
Generates the necessary jobfile and submits job for a batch

\end{fulllineitems}

\index{to\_ssh() (machine.cray.Cray method)@\spxentry{to\_ssh()}\spxextra{machine.cray.Cray method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.cray.Cray.to_ssh}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{to\_ssh}}}{\emph{args}}{}
converts a command into the same command passed via ssh
(each argument is an item of a list; in the ssh command, 
the original command appears as one argument and thus one 
string)

\end{fulllineitems}

\index{wait\_finished() (machine.cray.Cray method)@\spxentry{wait\_finished()}\spxextra{machine.cray.Cray method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.cray.Cray.wait_finished}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{wait\_finished}}}{}{}
Monitors all jobs on Cray Hazelhen HPC queue. 
Checks if jobfile finished.

\end{fulllineitems}


\end{fulllineitems}

\index{Option (class in machine.cray)@\spxentry{Option}\spxextra{class in machine.cray}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.cray.Option}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{machine.cray.}}\sphinxbfcode{\sphinxupquote{Option}}}{\emph{batch}, \emph{n\_sequential\_runs=None}, \emph{n\_parallel\_runs=None}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

One combination of n\_parallel\_runs and n\_sequential\_runs. 
Has a Rating based on efficiency (few idling cores) and expcted 
queuing time.
Invalid if does not match criteria of selected queue.
\index{check\_valid() (machine.cray.Option method)@\spxentry{check\_valid()}\spxextra{machine.cray.Option method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.cray.Option.check_valid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_valid}}}{\emph{batch}}{}
Invalid if does not match criteria of selected queue.

\end{fulllineitems}

\index{rating() (machine.cray.Option method)@\spxentry{rating()}\spxextra{machine.cray.Option method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.cray.Option.rating}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{rating}}}{\emph{batch}}{}
Rating based on efficiency (few idling cores) and expcted 
queuing time.

\end{fulllineitems}


\end{fulllineitems}

\index{get\_queue() (in module machine.cray)@\spxentry{get\_queue()}\spxextra{in module machine.cray}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.cray.get_queue}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{machine.cray.}}\sphinxbfcode{\sphinxupquote{get\_queue}}}{\emph{batch}}{}
check which queue the job is eligible for: 
if possible, run on multi. If too small, run on small. 
If too large, run on long (\textgreater{}4h)

\end{fulllineitems}

\index{long\_queue() (in module machine.cray)@\spxentry{long\_queue()}\spxextra{in module machine.cray}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.cray.long_queue}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{machine.cray.}}\sphinxbfcode{\sphinxupquote{long\_queue}}}{\emph{batch}}{}
with max\_cores, walltime exceeds 4h

\end{fulllineitems}

\index{multi\_queue() (in module machine.cray)@\spxentry{multi\_queue()}\spxextra{in module machine.cray}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.cray.multi_queue}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{machine.cray.}}\sphinxbfcode{\sphinxupquote{multi\_queue}}}{\emph{batch}}{}
preferred queue: n\_nodes\textgreater{}=48, walltime \textless{} 4h

\end{fulllineitems}

\index{small\_queue() (in module machine.cray)@\spxentry{small\_queue()}\spxextra{in module machine.cray}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.cray.small_queue}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{machine.cray.}}\sphinxbfcode{\sphinxupquote{small\_queue}}}{\emph{batch}}{}
multi queue cannot be filled with walltime \textgreater{} 5 min

\end{fulllineitems}



\section{machine.local module}
\label{\detokenize{machine:module-machine.local}}\label{\detokenize{machine:machine-local-module}}\index{machine.local (module)@\spxentry{machine.local}\spxextra{module}}\index{Local (class in machine.local)@\spxentry{Local}\spxextra{class in machine.local}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.local.Local}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{machine.local.}}\sphinxbfcode{\sphinxupquote{Local}}}{\emph{*args}}{}
Bases: {\hyperref[\detokenize{machine:machine.machine.Machine}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{machine.machine.Machine}}}}}

Class: Defines local machine.
Since no queuing is required, this all reduces
to very basic routines.
\index{allocate\_resources() (machine.local.Local method)@\spxentry{allocate\_resources()}\spxextra{machine.local.Local method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.local.Local.allocate_resources}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{allocate\_resources}}}{}{}
\end{fulllineitems}

\index{defaults\_ (machine.local.Local attribute)@\spxentry{defaults\_}\spxextra{machine.local.Local attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.local.Local.defaults_}}\pysigline{\sphinxbfcode{\sphinxupquote{defaults\_}}\sphinxbfcode{\sphinxupquote{ = \{'mpi': 'NODEFAULT'\}}}}
\end{fulllineitems}

\index{defaults\_add (machine.local.Local attribute)@\spxentry{defaults\_add}\spxextra{machine.local.Local attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.local.Local.defaults_add}}\pysigline{\sphinxbfcode{\sphinxupquote{defaults\_add}}\sphinxbfcode{\sphinxupquote{ = \{'Batch': \{'avg\_walltime': 'dummy\_unused', 'cores\_per\_sample': 1\}\}}}}
\end{fulllineitems}

\index{run\_batches() (machine.local.Local method)@\spxentry{run\_batches()}\spxextra{machine.local.Local method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.local.Local.run_batches}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run\_batches}}}{}{}
Runs a job by calling a subprocess.

\end{fulllineitems}


\end{fulllineitems}



\section{machine.machine module}
\label{\detokenize{machine:module-machine.machine}}\label{\detokenize{machine:machine-machine-module}}\index{machine.machine (module)@\spxentry{machine.machine}\spxextra{module}}\index{Machine (class in machine.machine)@\spxentry{Machine}\spxextra{class in machine.machine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{machine:machine.machine.Machine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{machine.machine.}}\sphinxbfcode{\sphinxupquote{Machine}}}{\emph{*args}}{}
Bases: {\hyperref[\detokenize{simulation:simulation.simulation.Stage}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{simulation.simulation.Stage}}}}}, {\hyperref[\detokenize{helpers:helpers.baseclass.BaseClass}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{helpers.baseclass.BaseClass}}}}}

defines the machine that an external job is run on. 
We call the processing of an external job (i.e. allocating 
resouces, preparation, and running) as a stage. 
Each stage can (theoretically) be run on a different machine.
E.g., post-processing can be doen locally.
Therefore, the different stages are instances of machine 
subclasses.

\end{fulllineitems}



\section{Module contents}
\label{\detokenize{machine:module-machine}}\label{\detokenize{machine:module-contents}}\index{machine (module)@\spxentry{machine}\spxextra{module}}

\chapter{sampling package}
\label{\detokenize{sampling:sampling-package}}\label{\detokenize{sampling::doc}}

\section{Submodules}
\label{\detokenize{sampling:submodules}}

\section{sampling.sampling module}
\label{\detokenize{sampling:module-sampling.sampling}}\label{\detokenize{sampling:sampling-sampling-module}}\index{sampling.sampling (module)@\spxentry{sampling.sampling}\spxextra{module}}\index{Collocation (class in sampling.sampling)@\spxentry{Collocation}\spxextra{class in sampling.sampling}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sampling:sampling.sampling.Collocation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{sampling.sampling.}}\sphinxbfcode{\sphinxupquote{Collocation}}}{\emph{class\_dict}, \emph{*further\_classes}}{}
Bases: {\hyperref[\detokenize{sampling:sampling.sampling.Sampling}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{sampling.sampling.Sampling}}}}}

Sampling at collocation nodes based on ChaosPy routines
Smolyak sparse grid is possible
\index{defaults\_ (sampling.sampling.Collocation attribute)@\spxentry{defaults\_}\spxextra{sampling.sampling.Collocation attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sampling:sampling.sampling.Collocation.defaults_}}\pysigline{\sphinxbfcode{\sphinxupquote{defaults\_}}\sphinxbfcode{\sphinxupquote{ = \{'poly\_deg': 'NODEFAULT', 'sparse\_grid': 'NODEFAULT'\}}}}
\end{fulllineitems}

\index{get() (sampling.sampling.Collocation method)@\spxentry{get()}\spxextra{sampling.sampling.Collocation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sampling:sampling.sampling.Collocation.get}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get}}}{}{}
get samples

\end{fulllineitems}

\index{sampling\_prms() (sampling.sampling.Collocation method)@\spxentry{sampling\_prms()}\spxextra{sampling.sampling.Collocation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sampling:sampling.sampling.Collocation.sampling_prms}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sampling\_prms}}}{}{}
For mean and variance, only weights would be used. 
The rest is for response surface creation.

\end{fulllineitems}


\end{fulllineitems}

\index{MonteCarlo (class in sampling.sampling)@\spxentry{MonteCarlo}\spxextra{class in sampling.sampling}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sampling:sampling.sampling.MonteCarlo}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{sampling.sampling.}}\sphinxbfcode{\sphinxupquote{MonteCarlo}}}{\emph{class\_dict}, \emph{*further\_classes}}{}
Bases: {\hyperref[\detokenize{sampling:sampling.sampling.Sampling}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{sampling.sampling.Sampling}}}}}

Vanilla Monte Carlo sampling
\index{get() (sampling.sampling.MonteCarlo method)@\spxentry{get()}\spxextra{sampling.sampling.MonteCarlo method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sampling:sampling.sampling.MonteCarlo.get}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get}}}{}{}
get samples

\end{fulllineitems}

\index{sampling\_prms() (sampling.sampling.MonteCarlo method)@\spxentry{sampling\_prms()}\spxextra{sampling.sampling.MonteCarlo method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sampling:sampling.sampling.MonteCarlo.sampling_prms}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sampling\_prms}}}{}{}
parameters specific to the sampling strategy which are
needed by the solver or by the post-processing routines

\end{fulllineitems}


\end{fulllineitems}

\index{Sampling (class in sampling.sampling)@\spxentry{Sampling}\spxextra{class in sampling.sampling}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sampling:sampling.sampling.Sampling}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{sampling.sampling.}}\sphinxbfcode{\sphinxupquote{Sampling}}}{\emph{class\_dict}, \emph{*further\_classes}}{}
Bases: {\hyperref[\detokenize{helpers:helpers.baseclass.BaseClass}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{helpers.baseclass.BaseClass}}}}}

parent class with placeholders for the sampling strategies
\index{get() (sampling.sampling.Sampling method)@\spxentry{get()}\spxextra{sampling.sampling.Sampling method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sampling:sampling.sampling.Sampling.get}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get}}}{}{}
get samples

\end{fulllineitems}

\index{sampling\_prms() (sampling.sampling.Sampling method)@\spxentry{sampling\_prms()}\spxextra{sampling.sampling.Sampling method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sampling:sampling.sampling.Sampling.sampling_prms}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sampling\_prms}}}{}{}
parameters specific to the sampling strategy which are
needed by the solver or by the post-processing routines

\end{fulllineitems}


\end{fulllineitems}



\section{Module contents}
\label{\detokenize{sampling:module-sampling}}\label{\detokenize{sampling:module-contents}}\index{sampling (module)@\spxentry{sampling}\spxextra{module}}

\chapter{simulation package}
\label{\detokenize{simulation:simulation-package}}\label{\detokenize{simulation::doc}}

\section{Submodules}
\label{\detokenize{simulation:submodules}}

\section{simulation.simulation module}
\label{\detokenize{simulation:module-simulation.simulation}}\label{\detokenize{simulation:simulation-simulation-module}}\index{simulation.simulation (module)@\spxentry{simulation.simulation}\spxextra{module}}\index{Iteration (class in simulation.simulation)@\spxentry{Iteration}\spxextra{class in simulation.simulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:simulation.simulation.Iteration}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{simulation.simulation.}}\sphinxbfcode{\sphinxupquote{Iteration}}}{\emph{n=None}, \emph{name=None}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Helper class for iterations. Could be extended in the future 
to store all information about samples etc. which is currently
overwritten. 
Note that the “iteration” decorator is located in globels.
\index{start() (simulation.simulation.Iteration method)@\spxentry{start()}\spxextra{simulation.simulation.Iteration method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:simulation.simulation.Iteration.start}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{start}}}{}{}
StdOut of A) section and B) skipped steps in case of a restart.

\end{fulllineitems}


\end{fulllineitems}

\index{Simulation (class in simulation.simulation)@\spxentry{Simulation}\spxextra{class in simulation.simulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:simulation.simulation.Simulation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{simulation.simulation.}}\sphinxbfcode{\sphinxupquote{Simulation}}}{\emph{class\_dict}}{}
Bases: {\hyperref[\detokenize{helpers:helpers.baseclass.BaseClass}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{helpers.baseclass.BaseClass}}}}}

Organizes how the simulation is run, i.e. how iterations follow 
each other in a loop and how an iteration looks. 
Simulation is a parent class to UqMethod, where routines can be
overwritten.
\index{process\_simulation\_postproc() (simulation.simulation.Simulation method)@\spxentry{process\_simulation\_postproc()}\spxextra{simulation.simulation.Simulation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:simulation.simulation.Simulation.process_simulation_postproc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{process\_simulation\_postproc}}}{}{}
\end{fulllineitems}

\index{run() (simulation.simulation.Simulation method)@\spxentry{run()}\spxextra{simulation.simulation.Simulation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:simulation.simulation.Simulation.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{}{}
Default main simulation loop: Iterate until finished or 
maximum number of iterations is reached, the npost-process 
if necessary.

\end{fulllineitems}

\index{run\_iteration() (simulation.simulation.Simulation method)@\spxentry{run\_iteration()}\spxextra{simulation.simulation.Simulation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:simulation.simulation.Simulation.run_iteration}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run\_iteration}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Stage (class in simulation.simulation)@\spxentry{Stage}\spxextra{class in simulation.simulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:simulation.simulation.Stage}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{simulation.simulation.}}\sphinxbfcode{\sphinxupquote{Stage}}}{\emph{*args}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

A Stage is a set of batches that is run externally. 
This can be simulations or post-processing. 
Processing this stage includes determining the required resources
on the system, preparation (writing input) and running the jobs. 
Each stage can be run on a different system. The according subclass
of Machine therefore inherits from Stage.
\index{active\_batches (simulation.simulation.Stage attribute)@\spxentry{active\_batches}\spxextra{simulation.simulation.Stage attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:simulation.simulation.Stage.active_batches}}\pysigline{\sphinxbfcode{\sphinxupquote{active\_batches}}}
if no samples are computed in this iteration, 
the batch is not active.

\end{fulllineitems}

\index{check\_all\_finished() (simulation.simulation.Stage method)@\spxentry{check\_all\_finished()}\spxextra{simulation.simulation.Stage method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:simulation.simulation.Stage.check_all_finished}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_all\_finished}}}{}{}
\end{fulllineitems}

\index{fill() (simulation.simulation.Stage method)@\spxentry{fill()}\spxextra{simulation.simulation.Stage method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:simulation.simulation.Stage.fill}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fill}}}{\emph{name}, \emph{multi\_sample}}{}
\end{fulllineitems}

\index{prepare\_set() (simulation.simulation.Stage method)@\spxentry{prepare\_set()}\spxextra{simulation.simulation.Stage method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:simulation.simulation.Stage.prepare_set}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{prepare\_set}}}{}{}
Wrapper for preparation of all batches

\end{fulllineitems}

\index{process() (simulation.simulation.Stage method)@\spxentry{process()}\spxextra{simulation.simulation.Stage method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:simulation.simulation.Stage.process}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{process}}}{}{}
core function of the class: process the stage

\end{fulllineitems}

\index{unfinished\_batches (simulation.simulation.Stage attribute)@\spxentry{unfinished\_batches}\spxextra{simulation.simulation.Stage attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:simulation.simulation.Stage.unfinished_batches}}\pysigline{\sphinxbfcode{\sphinxupquote{unfinished\_batches}}}
\end{fulllineitems}


\end{fulllineitems}



\section{Module contents}
\label{\detokenize{simulation:module-simulation}}\label{\detokenize{simulation:module-contents}}\index{simulation (module)@\spxentry{simulation}\spxextra{module}}

\chapter{solver package}
\label{\detokenize{solver:solver-package}}\label{\detokenize{solver::doc}}

\section{Submodules}
\label{\detokenize{solver:submodules}}

\section{solver.flexi module}
\label{\detokenize{solver:module-solver.flexi}}\label{\detokenize{solver:solver-flexi-module}}\index{solver.flexi (module)@\spxentry{solver.flexi}\spxextra{module}}\index{FieldSolution (class in solver.flexi)@\spxentry{FieldSolution}\spxextra{class in solver.flexi}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.flexi.FieldSolution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{solver.flexi.}}\sphinxbfcode{\sphinxupquote{FieldSolution}}}{\emph{*args}}{}
Bases: \sphinxcode{\sphinxupquote{solver.flexi.QoI}}

Takes the whole field solution as quantity of interest.

Caution: routines starting with {\color{red}\bfseries{}prepare\_}… 
will be renamed to “prepare” as part of the create\_by\_stage
routine.
\index{prepare\_iteration\_postproc() (solver.flexi.FieldSolution method)@\spxentry{prepare\_iteration\_postproc()}\spxextra{solver.flexi.FieldSolution method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.flexi.FieldSolution.prepare_iteration_postproc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{prepare\_iteration\_postproc}}}{}{}
\end{fulllineitems}

\index{prepare\_simulation\_postproc() (solver.flexi.FieldSolution method)@\spxentry{prepare\_simulation\_postproc()}\spxextra{solver.flexi.FieldSolution method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.flexi.FieldSolution.prepare_simulation_postproc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{prepare\_simulation\_postproc}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Flexi (class in solver.flexi)@\spxentry{Flexi}\spxextra{class in solver.flexi}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.flexi.Flexi}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{solver.flexi.}}\sphinxbfcode{\sphinxupquote{Flexi}}}{\emph{*args}}{}
Bases: {\hyperref[\detokenize{solver:solver.solver.Solver}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{solver.solver.Solver}}}}}

Runs with the POUNCE-adaptation of FLEXI, i.e. with the 
executable flexibatch and the according post-processing tools.
\index{Flexi.QoI (class in solver.flexi)@\spxentry{Flexi.QoI}\spxextra{class in solver.flexi}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.flexi.Flexi.QoI}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{QoI}}}{\emph{*args}}{}
Bases: {\hyperref[\detokenize{solver:solver.solver.QoI}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{solver.solver.QoI}}}}}

Parent class for all FLEXI QoI’s
\index{defaults\_ (solver.flexi.Flexi.QoI attribute)@\spxentry{defaults\_}\spxextra{solver.flexi.Flexi.QoI attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.flexi.Flexi.QoI.defaults_}}\pysigline{\sphinxbfcode{\sphinxupquote{defaults\_}}\sphinxbfcode{\sphinxupquote{ = \{'prmfile': ''\}}}}
\end{fulllineitems}

\index{get\_derived\_quantity() (solver.flexi.Flexi.QoI method)@\spxentry{get\_derived\_quantity()}\spxextra{solver.flexi.Flexi.QoI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.flexi.Flexi.QoI.get_derived_quantity}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_derived\_quantity}}}{\emph{quantity\_name}}{}
Readin sigma\_sq or avg\_walltime for MLMC.

\end{fulllineitems}

\index{get\_work\_mean() (solver.flexi.Flexi.QoI method)@\spxentry{get\_work\_mean()}\spxextra{solver.flexi.Flexi.QoI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.flexi.Flexi.QoI.get_work_mean}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_work\_mean}}}{}{}
For Flexi, avg work is already read from HDF5 file during 
check\_all\_finished

\end{fulllineitems}


\end{fulllineitems}

\index{check\_finished() (solver.flexi.Flexi method)@\spxentry{check\_finished()}\spxextra{solver.flexi.Flexi method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.flexi.Flexi.check_finished}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_finished}}}{}{}
Check last lines of logfiles (stdout) for confirmation that 
the batch is finished. Also retrieve average work, which is 
written to the log file as well (as part of flexibatch)

\end{fulllineitems}

\index{defaults\_ (solver.flexi.Flexi attribute)@\spxentry{defaults\_}\spxextra{solver.flexi.Flexi attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.flexi.Flexi.defaults_}}\pysigline{\sphinxbfcode{\sphinxupquote{defaults\_}}\sphinxbfcode{\sphinxupquote{ = \{'prmfile': 'parameter\_flexi.ini', 'solver\_prms': \{'MeshFile': 'NODEFAULT', 'N': 'NODEFAULT'\}\}}}}
\end{fulllineitems}

\index{defaults\_add (solver.flexi.Flexi attribute)@\spxentry{defaults\_add}\spxextra{solver.flexi.Flexi attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.flexi.Flexi.defaults_add}}\pysigline{\sphinxbfcode{\sphinxupquote{defaults\_add}}\sphinxbfcode{\sphinxupquote{ = \{'StochVar': \{'i\_occurrence': \{\}, 'i\_pos': \{\}, 'name': 'NODEFAULT'\}\}}}}
\end{fulllineitems}

\index{h5write() (solver.flexi.Flexi method)@\spxentry{h5write()}\spxextra{solver.flexi.Flexi method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.flexi.Flexi.h5write}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{h5write}}}{\emph{h5f}, \emph{name}, \emph{prm}}{}
helper function for correct data formatting 
in Fortran readable HDF5 files.

\end{fulllineitems}

\index{prepare() (solver.flexi.Flexi method)@\spxentry{prepare()}\spxextra{solver.flexi.Flexi method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.flexi.Flexi.prepare}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{prepare}}}{}{}
Prepares the simulation by generating the run\_command
and writing the HDF5 file containing all samples of the current
iteration and the current samples.

\end{fulllineitems}

\index{write\_hdf5() (solver.flexi.Flexi method)@\spxentry{write\_hdf5()}\spxextra{solver.flexi.Flexi method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.flexi.Flexi.write_hdf5}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{write\_hdf5}}}{\emph{file\_name}, \emph{solver\_prms}, \emph{further\_prms}}{}
Writes the HDF5 file containing all necessary data for
flexi run to run.

\end{fulllineitems}


\end{fulllineitems}

\index{RecordPoints (class in solver.flexi)@\spxentry{RecordPoints}\spxextra{class in solver.flexi}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.flexi.RecordPoints}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{solver.flexi.}}\sphinxbfcode{\sphinxupquote{RecordPoints}}}{\emph{*args}}{}
Bases: \sphinxcode{\sphinxupquote{solver.flexi.QoI}}

Takes a solution time sereis evaluated at record points as QoI.

Caution: routines starting with {\color{red}\bfseries{}prepare\_}… 
will be renamed to “prepare” as part of the create\_by\_stage
routine.
\index{defaults\_ (solver.flexi.RecordPoints attribute)@\spxentry{defaults\_}\spxextra{solver.flexi.RecordPoints attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.flexi.RecordPoints.defaults_}}\pysigline{\sphinxbfcode{\sphinxupquote{defaults\_}}\sphinxbfcode{\sphinxupquote{ = \{'time\_span': {[}0.0, 10000000000.0{]}\}}}}
\end{fulllineitems}

\index{prepare\_iteration\_postproc() (solver.flexi.RecordPoints method)@\spxentry{prepare\_iteration\_postproc()}\spxextra{solver.flexi.RecordPoints method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.flexi.RecordPoints.prepare_iteration_postproc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{prepare\_iteration\_postproc}}}{}{}
\end{fulllineitems}

\index{prepare\_simulation\_postproc() (solver.flexi.RecordPoints method)@\spxentry{prepare\_simulation\_postproc()}\spxextra{solver.flexi.RecordPoints method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.flexi.RecordPoints.prepare_simulation_postproc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{prepare\_simulation\_postproc}}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\section{solver.internal module}
\label{\detokenize{solver:module-solver.internal}}\label{\detokenize{solver:solver-internal-module}}\index{solver.internal (module)@\spxentry{solver.internal}\spxextra{module}}\index{Integral (class in solver.internal)@\spxentry{Integral}\spxextra{class in solver.internal}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.internal.Integral}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{solver.internal.}}\sphinxbfcode{\sphinxupquote{Integral}}}{\emph{*args}}{}
Bases: \sphinxcode{\sphinxupquote{solver.internal.QoI}}

Takes the integral of the solution as quantity of interest.

Caution: routines starting with {\color{red}\bfseries{}prepare\_}… 
will be renamed to “prepare” as part of the create\_by\_stage
routine.
\index{prepare\_iteration\_postproc() (solver.internal.Integral method)@\spxentry{prepare\_iteration\_postproc()}\spxextra{solver.internal.Integral method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.internal.Integral.prepare_iteration_postproc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{prepare\_iteration\_postproc}}}{}{}
\end{fulllineitems}

\index{prepare\_simulation\_postproc() (solver.internal.Integral method)@\spxentry{prepare\_simulation\_postproc()}\spxextra{solver.internal.Integral method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.internal.Integral.prepare_simulation_postproc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{prepare\_simulation\_postproc}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Internal (class in solver.internal)@\spxentry{Internal}\spxextra{class in solver.internal}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.internal.Internal}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{solver.internal.}}\sphinxbfcode{\sphinxupquote{Internal}}}{\emph{*args}}{}
Bases: {\hyperref[\detokenize{solver:solver.solver.Solver}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{solver.solver.Solver}}}}}

Dummy python solver for testing.
python source files are located in the externals directory
I/O via HDF5.
\index{Internal.QoI (class in solver.internal)@\spxentry{Internal.QoI}\spxextra{class in solver.internal}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.internal.Internal.QoI}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{QoI}}}{\emph{*args}}{}
Bases: {\hyperref[\detokenize{solver:solver.solver.QoI}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{solver.solver.QoI}}}}}

Parent class for the dummy solver’s QoI(s)
\index{get\_derived\_quantity() (solver.internal.Internal.QoI method)@\spxentry{get\_derived\_quantity()}\spxextra{solver.internal.Internal.QoI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.internal.Internal.QoI.get_derived_quantity}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_derived\_quantity}}}{\emph{quantity\_name}}{}
Readin sigma\_sq for MLMC.

\end{fulllineitems}

\index{get\_work\_mean() (solver.internal.Internal.QoI method)@\spxentry{get\_work\_mean()}\spxextra{solver.internal.Internal.QoI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.internal.Internal.QoI.get_work_mean}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_work\_mean}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{defaults\_ (solver.internal.Internal attribute)@\spxentry{defaults\_}\spxextra{solver.internal.Internal attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.internal.Internal.defaults_}}\pysigline{\sphinxbfcode{\sphinxupquote{defaults\_}}\sphinxbfcode{\sphinxupquote{ = \{'solver\_prms': \{'nPoints': 'NODEFAULT'\}\}}}}
\end{fulllineitems}

\index{h5write() (solver.internal.Internal method)@\spxentry{h5write()}\spxextra{solver.internal.Internal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.internal.Internal.h5write}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{h5write}}}{\emph{h5f}, \emph{name}, \emph{prm}}{}
\end{fulllineitems}

\index{prepare() (solver.internal.Internal method)@\spxentry{prepare()}\spxextra{solver.internal.Internal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.internal.Internal.prepare}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{prepare}}}{}{}
Prepares the simulation by generating the run\_command 
and writing the HDF5 file containing all samples of the current 
iteration and the current level.

\end{fulllineitems}

\index{write\_hdf5() (solver.internal.Internal method)@\spxentry{write\_hdf5()}\spxextra{solver.internal.Internal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.internal.Internal.write_hdf5}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{write\_hdf5}}}{\emph{file\_name}, \emph{prms}}{}
Writes the HDF5 file containing all necessary data for the 
internal to run.

\end{fulllineitems}


\end{fulllineitems}



\section{solver.solver module}
\label{\detokenize{solver:module-solver.solver}}\label{\detokenize{solver:solver-solver-module}}\index{solver.solver (module)@\spxentry{solver.solver}\spxextra{module}}\index{Batch (class in solver.solver)@\spxentry{Batch}\spxextra{class in solver.solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.solver.Batch}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{solver.solver.}}\sphinxbfcode{\sphinxupquote{Batch}}}{\emph{class\_dict}, \emph{*further\_classes}}{}
Bases: {\hyperref[\detokenize{helpers:helpers.baseclass.BaseClass}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{helpers.baseclass.BaseClass}}}}}

A batch consists of a set of computations.
This can be either simulations or post-processing.
It is therefore the parent class to Solver and QoI
\index{check\_finished() (solver.solver.Batch method)@\spxentry{check\_finished()}\spxextra{solver.solver.Batch method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.solver.Batch.check_finished}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_finished}}}{}{}
default: do not carry out a check after a batch is run
simply assume all are finished.

\end{fulllineitems}

\index{defaults\_ (solver.solver.Batch attribute)@\spxentry{defaults\_}\spxextra{solver.solver.Batch attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.solver.Batch.defaults_}}\pysigline{\sphinxbfcode{\sphinxupquote{defaults\_}}\sphinxbfcode{\sphinxupquote{ = \{'avg\_walltime': 300.0, 'cores\_per\_sample': 1, 'exe\_path': 'NODEFAULT'\}}}}
\end{fulllineitems}

\index{errfile\_names (solver.solver.Batch attribute)@\spxentry{errfile\_names}\spxextra{solver.solver.Batch attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.solver.Batch.errfile_names}}\pysigline{\sphinxbfcode{\sphinxupquote{errfile\_names}}}
\end{fulllineitems}

\index{logfile\_names (solver.solver.Batch attribute)@\spxentry{logfile\_names}\spxextra{solver.solver.Batch attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.solver.Batch.logfile_names}}\pysigline{\sphinxbfcode{\sphinxupquote{logfile\_names}}}
\end{fulllineitems}

\index{n\_runs (solver.solver.Batch attribute)@\spxentry{n\_runs}\spxextra{solver.solver.Batch attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.solver.Batch.n_runs}}\pysigline{\sphinxbfcode{\sphinxupquote{n\_runs}}}
\end{fulllineitems}

\index{prepare() (solver.solver.Batch method)@\spxentry{prepare()}\spxextra{solver.solver.Batch method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.solver.Batch.prepare}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{prepare}}}{\emph{simulation}}{}
placeholder; should be overwritten by each subclass.

\end{fulllineitems}

\index{run\_id() (solver.solver.Batch method)@\spxentry{run\_id()}\spxextra{solver.solver.Batch method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.solver.Batch.run_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run\_id}}}{\emph{i}}{}
needed to distinguish input and output files 
in the case of several runs per batch (i.e. if one solver is
run several times instead of a loop over all samples as part 
of the external solver)

\end{fulllineitems}


\end{fulllineitems}

\index{QoI (class in solver.solver)@\spxentry{QoI}\spxextra{class in solver.solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.solver.QoI}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{solver.solver.}}\sphinxbfcode{\sphinxupquote{QoI}}}{\emph{*args}}{}
Bases: {\hyperref[\detokenize{solver:solver.solver.Batch}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{solver.solver.Batch}}}}}

QoIs are always chosen automatically according 
to the chosen Solver.
\index{create\_by\_stage() (solver.solver.QoI class method)@\spxentry{create\_by\_stage()}\spxextra{solver.solver.QoI class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.solver.QoI.create_by_stage}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{create\_by\_stage}}}{\emph{name}, \emph{prms}, \emph{*args}}{}
Some QoI’s contain prepare functions for different stages. 
Here, the functions are renamed to the general “prepare” 
according to the respective stage string given in “name”.
QoI parameters are joined: some are given for all stages
(prms\_other), others are stage-specific (prms\_loc).

\end{fulllineitems}


\end{fulllineitems}

\index{Solver (class in solver.solver)@\spxentry{Solver}\spxextra{class in solver.solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.solver.Solver}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{solver.solver.}}\sphinxbfcode{\sphinxupquote{Solver}}}{\emph{*args}}{}
Bases: {\hyperref[\detokenize{solver:solver.solver.Batch}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{solver.solver.Batch}}}}}

Solver is the parent class to subclasses which include 
routines specidifc to the used solver. Here only the main
simulation is considered as opposed to the according QoI’s, 
which are defined separately.
\index{defaults\_ (solver.solver.Solver attribute)@\spxentry{defaults\_}\spxextra{solver.solver.Solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.solver.Solver.defaults_}}\pysigline{\sphinxbfcode{\sphinxupquote{defaults\_}}\sphinxbfcode{\sphinxupquote{ = \{'avg\_walltime': 'NODEFAULT', 'cores\_per\_sample': 'NODEFAULT', 'solver\_prms': 'NODEFAULT'\}}}}
\end{fulllineitems}


\end{fulllineitems}



\section{Module contents}
\label{\detokenize{solver:module-solver}}\label{\detokenize{solver:module-contents}}\index{solver (module)@\spxentry{solver}\spxextra{module}}

\chapter{stochvar package}
\label{\detokenize{stochvar:stochvar-package}}\label{\detokenize{stochvar::doc}}

\section{Submodules}
\label{\detokenize{stochvar:submodules}}

\section{stochvar.stochvar module}
\label{\detokenize{stochvar:module-stochvar.stochvar}}\label{\detokenize{stochvar:stochvar-stochvar-module}}\index{stochvar.stochvar (module)@\spxentry{stochvar.stochvar}\spxextra{module}}\index{Normal (class in stochvar.stochvar)@\spxentry{Normal}\spxextra{class in stochvar.stochvar}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{stochvar:stochvar.stochvar.Normal}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{stochvar.stochvar.}}\sphinxbfcode{\sphinxupquote{Normal}}}{\emph{input\_prm\_dict}, \emph{*args}}{}
Bases: {\hyperref[\detokenize{stochvar:stochvar.stochvar.StochVar}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{stochvar.stochvar.StochVar}}}}}

normal distribution
uses numpy and chaospy routines
\index{defaults\_ (stochvar.stochvar.Normal attribute)@\spxentry{defaults\_}\spxextra{stochvar.stochvar.Normal attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{stochvar:stochvar.stochvar.Normal.defaults_}}\pysigline{\sphinxbfcode{\sphinxupquote{defaults\_}}\sphinxbfcode{\sphinxupquote{ = \{'mean': 'NODEFAULT', 'standard\_deviation': 'NODEFAULT'\}}}}
\end{fulllineitems}

\index{draw\_samples() (stochvar.stochvar.Normal method)@\spxentry{draw\_samples()}\spxextra{stochvar.stochvar.Normal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{stochvar:stochvar.stochvar.Normal.draw_samples}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{draw\_samples}}}{\emph{n\_samples}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{StochVar (class in stochvar.stochvar)@\spxentry{StochVar}\spxextra{class in stochvar.stochvar}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{stochvar:stochvar.stochvar.StochVar}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{stochvar.stochvar.}}\sphinxbfcode{\sphinxupquote{StochVar}}}{\emph{class\_dict}, \emph{*further\_classes}}{}
Bases: {\hyperref[\detokenize{helpers:helpers.baseclass.BaseClass}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{helpers.baseclass.BaseClass}}}}}

parent class for stochastic variables

\end{fulllineitems}

\index{Uniform (class in stochvar.stochvar)@\spxentry{Uniform}\spxextra{class in stochvar.stochvar}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{stochvar:stochvar.stochvar.Uniform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{stochvar.stochvar.}}\sphinxbfcode{\sphinxupquote{Uniform}}}{\emph{input\_prm\_dict}, \emph{*args}}{}
Bases: {\hyperref[\detokenize{stochvar:stochvar.stochvar.StochVar}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{stochvar.stochvar.StochVar}}}}}

uniform distribution
uses numpy and chaospy routines
\index{defaults\_ (stochvar.stochvar.Uniform attribute)@\spxentry{defaults\_}\spxextra{stochvar.stochvar.Uniform attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{stochvar:stochvar.stochvar.Uniform.defaults_}}\pysigline{\sphinxbfcode{\sphinxupquote{defaults\_}}\sphinxbfcode{\sphinxupquote{ = \{'bounds': 'NODEFAULT'\}}}}
\end{fulllineitems}

\index{draw\_samples() (stochvar.stochvar.Uniform method)@\spxentry{draw\_samples()}\spxextra{stochvar.stochvar.Uniform method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{stochvar:stochvar.stochvar.Uniform.draw_samples}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{draw\_samples}}}{\emph{n\_samples}}{}
\end{fulllineitems}


\end{fulllineitems}



\section{Module contents}
\label{\detokenize{stochvar:module-stochvar}}\label{\detokenize{stochvar:module-contents}}\index{stochvar (module)@\spxentry{stochvar}\spxextra{module}}

\chapter{uqmethod package}
\label{\detokenize{uqmethod:uqmethod-package}}\label{\detokenize{uqmethod::doc}}

\section{Submodules}
\label{\detokenize{uqmethod:submodules}}

\section{uqmethod.mlmc module}
\label{\detokenize{uqmethod:module-uqmethod.mlmc}}\label{\detokenize{uqmethod:uqmethod-mlmc-module}}\index{uqmethod.mlmc (module)@\spxentry{uqmethod.mlmc}\spxextra{module}}\index{Mlmc (class in uqmethod.mlmc)@\spxentry{Mlmc}\spxextra{class in uqmethod.mlmc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{uqmethod:uqmethod.mlmc.Mlmc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{uqmethod.mlmc.}}\sphinxbfcode{\sphinxupquote{Mlmc}}}{\emph{input\_prm\_dict}}{}
Bases: {\hyperref[\detokenize{uqmethod:uqmethod.uqmethod.UqMethod}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{uqmethod.uqmethod.UqMethod}}}}}

Multilevel Monte Carlo
The number of levels is prescribed, the number of samples is 
adapted iteratively in a prescribed number of iterations
(convergence rate and work per sample are obtained empirically).
\index{SamplingMethod (uqmethod.mlmc.Mlmc attribute)@\spxentry{SamplingMethod}\spxextra{uqmethod.mlmc.Mlmc attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{uqmethod:uqmethod.mlmc.Mlmc.SamplingMethod}}\pysigline{\sphinxbfcode{\sphinxupquote{SamplingMethod}}}
alias of {\hyperref[\detokenize{sampling:sampling.sampling.MonteCarlo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{sampling.sampling.MonteCarlo}}}}}

\end{fulllineitems}

\index{default\_yml() (uqmethod.mlmc.Mlmc class method)@\spxentry{default\_yml()}\spxextra{uqmethod.mlmc.Mlmc class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{uqmethod:uqmethod.mlmc.Mlmc.default_yml}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{default\_yml}}}{\emph{d}}{}
MLMC specific layout of the default yml file.

\end{fulllineitems}

\index{defaults\_ (uqmethod.mlmc.Mlmc attribute)@\spxentry{defaults\_}\spxextra{uqmethod.mlmc.Mlmc attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{uqmethod:uqmethod.mlmc.Mlmc.defaults_}}\pysigline{\sphinxbfcode{\sphinxupquote{defaults\_}}\sphinxbfcode{\sphinxupquote{ = \{'n\_max\_iter': 'NODEFAULT', 'reset\_seed': False, 'tolerance': None, 'total\_work': None\}}}}
\end{fulllineitems}

\index{defaults\_add (uqmethod.mlmc.Mlmc attribute)@\spxentry{defaults\_add}\spxextra{uqmethod.mlmc.Mlmc attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{uqmethod:uqmethod.mlmc.Mlmc.defaults_add}}\pysigline{\sphinxbfcode{\sphinxupquote{defaults\_add}}\sphinxbfcode{\sphinxupquote{ = \{'QoI': \{'optimize': False\}, 'Solver': \{'n\_warmup\_samples': 'NODEFAULT'\}\}}}}
\end{fulllineitems}

\index{prepare\_next\_iteration() (uqmethod.mlmc.Mlmc method)@\spxentry{prepare\_next\_iteration()}\spxextra{uqmethod.mlmc.Mlmc method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{uqmethod:uqmethod.mlmc.Mlmc.prepare_next_iteration}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{prepare\_next\_iteration}}}{}{}
Compute number of samples for next iteration. 
- evaluate sigma\textasciicircum{}2 and avg work. 
- get optimal number of samples on every level
\begin{quote}

(given prescribed tolerance or total work)
\end{quote}
\begin{itemize}
\item {} 
approach this numbr carefully and iteratively

\end{itemize}

\end{fulllineitems}

\index{setup() (uqmethod.mlmc.Mlmc method)@\spxentry{setup()}\spxextra{uqmethod.mlmc.Mlmc method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{uqmethod:uqmethod.mlmc.Mlmc.setup}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setup}}}{\emph{prms}}{}
Set up data structure for an MLMC simulation
Includes levels and sublevels, quantities of interest, 
each initiallized according to chosen solver, 
and stages (main simulation and post proc) according to
chosen machine.

\end{fulllineitems}

\index{setup\_level() (uqmethod.mlmc.Mlmc method)@\spxentry{setup\_level()}\spxextra{uqmethod.mlmc.Mlmc method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{uqmethod:uqmethod.mlmc.Mlmc.setup_level}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setup\_level}}}{\emph{i}, \emph{sub\_fine}, \emph{sub\_coarse}}{}
set up a level, connect to its sublevels, and 
add the samples container

\end{fulllineitems}

\index{setup\_qoi() (uqmethod.mlmc.Mlmc method)@\spxentry{setup\_qoi()}\spxextra{uqmethod.mlmc.Mlmc method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{uqmethod:uqmethod.mlmc.Mlmc.setup_qoi}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setup\_qoi}}}{\emph{subdict}, \emph{level}}{}
set up quantity of interest for a level and make the 
sublevels its participants

\end{fulllineitems}


\end{fulllineitems}



\section{uqmethod.sc module}
\label{\detokenize{uqmethod:module-uqmethod.sc}}\label{\detokenize{uqmethod:uqmethod-sc-module}}\index{uqmethod.sc (module)@\spxentry{uqmethod.sc}\spxextra{module}}\index{Sc (class in uqmethod.sc)@\spxentry{Sc}\spxextra{class in uqmethod.sc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{uqmethod:uqmethod.sc.Sc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{uqmethod.sc.}}\sphinxbfcode{\sphinxupquote{Sc}}}{\emph{input\_prm\_dict}}{}
Bases: {\hyperref[\detokenize{uqmethod:uqmethod.uqmethod.UqMethod}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{uqmethod.uqmethod.UqMethod}}}}}

Stochastic Collocation (non-adaptive)
\index{SamplingMethod (uqmethod.sc.Sc attribute)@\spxentry{SamplingMethod}\spxextra{uqmethod.sc.Sc attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{uqmethod:uqmethod.sc.Sc.SamplingMethod}}\pysigline{\sphinxbfcode{\sphinxupquote{SamplingMethod}}}
alias of {\hyperref[\detokenize{sampling:sampling.sampling.Collocation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{sampling.sampling.Collocation}}}}}

\end{fulllineitems}

\index{default\_yml() (uqmethod.sc.Sc class method)@\spxentry{default\_yml()}\spxextra{uqmethod.sc.Sc class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{uqmethod:uqmethod.sc.Sc.default_yml}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{default\_yml}}}{\emph{d}}{}
\end{fulllineitems}

\index{prepare\_next\_iteration() (uqmethod.sc.Sc method)@\spxentry{prepare\_next\_iteration()}\spxextra{uqmethod.sc.Sc method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{uqmethod:uqmethod.sc.Sc.prepare_next_iteration}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{prepare\_next\_iteration}}}{}{}
There is only one “iteration”, so no next 
one needs to be prepared.

\end{fulllineitems}

\index{setup() (uqmethod.sc.Sc method)@\spxentry{setup()}\spxextra{uqmethod.sc.Sc method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{uqmethod:uqmethod.sc.Sc.setup}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setup}}}{\emph{prms}}{}
Only one batch is needed (called solver)

\end{fulllineitems}


\end{fulllineitems}



\section{uqmethod.uqmethod module}
\label{\detokenize{uqmethod:module-uqmethod.uqmethod}}\label{\detokenize{uqmethod:uqmethod-uqmethod-module}}\index{uqmethod.uqmethod (module)@\spxentry{uqmethod.uqmethod}\spxextra{module}}\index{UqMethod (class in uqmethod.uqmethod)@\spxentry{UqMethod}\spxextra{class in uqmethod.uqmethod}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{uqmethod:uqmethod.uqmethod.UqMethod}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{uqmethod.uqmethod.}}\sphinxbfcode{\sphinxupquote{UqMethod}}}{\emph{class\_dict}}{}
Bases: {\hyperref[\detokenize{simulation:simulation.simulation.Simulation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{simulation.simulation.Simulation}}}}}, {\hyperref[\detokenize{helpers:helpers.baseclass.BaseClass}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{helpers.baseclass.BaseClass}}}}}

Parent class for different uq methods
Inherits from Simulation, since it is also the driver class for 
the whole simulation.
\index{default\_yml() (uqmethod.uqmethod.UqMethod class method)@\spxentry{default\_yml()}\spxextra{uqmethod.uqmethod.UqMethod class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{uqmethod:uqmethod.uqmethod.UqMethod.default_yml}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{default\_yml}}}{\emph{d}}{}
\end{fulllineitems}

\index{get\_samples() (uqmethod.uqmethod.UqMethod method)@\spxentry{get\_samples()}\spxextra{uqmethod.uqmethod.UqMethod method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{uqmethod:uqmethod.uqmethod.UqMethod.get_samples}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_samples}}}{\emph{batches}}{}
The sampling method is determined during setup, so this is 
just a simple wrapper.

\end{fulllineitems}


\end{fulllineitems}



\section{Module contents}
\label{\detokenize{uqmethod:module-uqmethod}}\label{\detokenize{uqmethod:module-contents}}\index{uqmethod (module)@\spxentry{uqmethod}\spxextra{module}}

\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{h}
\item\relax\sphinxstyleindexentry{helpers}\sphinxstyleindexpageref{helpers:\detokenize{module-helpers}}
\item\relax\sphinxstyleindexentry{helpers.baseclass}\sphinxstyleindexpageref{helpers:\detokenize{module-helpers.baseclass}}
\item\relax\sphinxstyleindexentry{helpers.config}\sphinxstyleindexpageref{helpers:\detokenize{module-helpers.config}}
\item\relax\sphinxstyleindexentry{helpers.default\_yml}\sphinxstyleindexpageref{helpers:\detokenize{module-helpers.default_yml}}
\item\relax\sphinxstyleindexentry{helpers.globels}\sphinxstyleindexpageref{helpers:\detokenize{module-helpers.globels}}
\item\relax\sphinxstyleindexentry{helpers.printtools}\sphinxstyleindexpageref{helpers:\detokenize{module-helpers.printtools}}
\item\relax\sphinxstyleindexentry{helpers.tools}\sphinxstyleindexpageref{helpers:\detokenize{module-helpers.tools}}
\indexspace
\bigletter{m}
\item\relax\sphinxstyleindexentry{machine}\sphinxstyleindexpageref{machine:\detokenize{module-machine}}
\item\relax\sphinxstyleindexentry{machine.cray}\sphinxstyleindexpageref{machine:\detokenize{module-machine.cray}}
\item\relax\sphinxstyleindexentry{machine.local}\sphinxstyleindexpageref{machine:\detokenize{module-machine.local}}
\item\relax\sphinxstyleindexentry{machine.machine}\sphinxstyleindexpageref{machine:\detokenize{module-machine.machine}}
\indexspace
\bigletter{s}
\item\relax\sphinxstyleindexentry{sampling}\sphinxstyleindexpageref{sampling:\detokenize{module-sampling}}
\item\relax\sphinxstyleindexentry{sampling.sampling}\sphinxstyleindexpageref{sampling:\detokenize{module-sampling.sampling}}
\item\relax\sphinxstyleindexentry{simulation}\sphinxstyleindexpageref{simulation:\detokenize{module-simulation}}
\item\relax\sphinxstyleindexentry{simulation.simulation}\sphinxstyleindexpageref{simulation:\detokenize{module-simulation.simulation}}
\item\relax\sphinxstyleindexentry{solver}\sphinxstyleindexpageref{solver:\detokenize{module-solver}}
\item\relax\sphinxstyleindexentry{solver.flexi}\sphinxstyleindexpageref{solver:\detokenize{module-solver.flexi}}
\item\relax\sphinxstyleindexentry{solver.internal}\sphinxstyleindexpageref{solver:\detokenize{module-solver.internal}}
\item\relax\sphinxstyleindexentry{solver.solver}\sphinxstyleindexpageref{solver:\detokenize{module-solver.solver}}
\item\relax\sphinxstyleindexentry{stochvar}\sphinxstyleindexpageref{stochvar:\detokenize{module-stochvar}}
\item\relax\sphinxstyleindexentry{stochvar.stochvar}\sphinxstyleindexpageref{stochvar:\detokenize{module-stochvar.stochvar}}
\indexspace
\bigletter{u}
\item\relax\sphinxstyleindexentry{uqmethod}\sphinxstyleindexpageref{uqmethod:\detokenize{module-uqmethod}}
\item\relax\sphinxstyleindexentry{uqmethod.mlmc}\sphinxstyleindexpageref{uqmethod:\detokenize{module-uqmethod.mlmc}}
\item\relax\sphinxstyleindexentry{uqmethod.sc}\sphinxstyleindexpageref{uqmethod:\detokenize{module-uqmethod.sc}}
\item\relax\sphinxstyleindexentry{uqmethod.uqmethod}\sphinxstyleindexpageref{uqmethod:\detokenize{module-uqmethod.uqmethod}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}